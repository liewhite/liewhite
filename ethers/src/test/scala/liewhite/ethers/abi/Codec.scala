package liewhite.ethers.abi

import liewhite.ethers.types.Address
import liewhite.json.{*, given}
import zio.json.ast.Json

case class A(a: Int, b: String = "123")
class CodecTest extends munit.FunSuite {
  test("int codec") {
    val intEncode = ABITypeInt(8).encode(1)
    assertEquals(intEncode.toSeq, "0x0000000000000000000000000000000000000000000000000000000000000001".hexToBytes.toSeq)
    val uintEncode = ABITypeUint(8).encode(1)
    assertEquals(
      uintEncode.toSeq,
      "0x0000000000000000000000000000000000000000000000000000000000000001".hexToBytes.toSeq
    )
    intercept[ABIException] {
      ABITypeInt(8).encode(128)
    }
    val bigIntEncode = ABITypeInt(8).encode(127)
    assertEquals(
      bigIntEncode.toSeq,
      "0x000000000000000000000000000000000000000000000000000000000000007f".hexToBytes.toSeq
    )

    val negIntEncode = ABITypeInt(8).encode(-128)
    assertEquals(
      negIntEncode.toSeq,
      "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80".hexToBytes.toSeq
    )
    intercept[ABIException] {
      ABITypeInt(8).encode(-129)
    }
  }

  test("simple tuple codec") {
    val tupleBs = ABITypeTuple(ABITypeInt(8), ABITypeAddress)
      .encode(1 -> Address.fromHex("0xe9a97B0798b1649045c1D7114F8C432846828404"))
    assertEquals(
      tupleBs.toSeq,
      "0x0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000e9a97b0798b1649045c1d7114f8c432846828404".hexToBytes.toSeq
    )
  }

  test("dynamic array codec") {
    val tupleBs = ABITypeTuple(ABITypeArray(ABITypeInt(8)), ABITypeArray(ABITypeBytes))
      .encode((Seq(1, 2, 3), Seq("0xff")))
    assertEquals(
      tupleBs.toSeq,
      "0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001ff00000000000000000000000000000000000000000000000000000000000000".hexToBytes.toSeq
    )
  }

  test("tuple array decoder") {
    val data =
      "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000331323300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003333231000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000033536360000000000000000000000000000000000000000000000000000000000".hexToBytes
    val decoder = ABITypeTuple(ABITypeArray(ABITypeString))
    val result  = decoder.decode(data)
    assertEquals(
      result,
      """[["123","321","566"]]""".fromJson[Json].toOption.get
    )
  }

  test("nested tuple encoder") {
    val encoder = ABITypeTuple(
      ABITypeTuple(ABITypeUint(256), ABITypeAddress, ABITypeUint(256), ABITypeBytes, ABITypeBytes, ABITypeBytes)
    )
    val result = encoder
      .encode(
        Tuple(
          (
            0,
            Address.fromHex("0x103dd1184599c7511a3016E0a383E11F84AE7173"),
            0,
            Array.emptyByteArray,
            Array.emptyByteArray,
            Array.emptyByteArray
          )
        )
      )
      .BytesToHex
    assertEquals(
      result,
      "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103dd1184599c7511a3016e0a383e11f84ae7173000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    )
  }

  test("nested array encoder") {
    val encoder = ABITypeTuple(
      ABITypeArray(
        ABITypeArray(ABITypeUint(256))
      )
    )
    val result = encoder
      .encode(Tuple(Seq(Seq(1, 2, 3), Seq(1, 2, 3))))
      .BytesToHex
    assertEquals(
      result,
      "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003"
    )
  }

  def simpleDecoder(data: String, decoder: ABIType, expect: Json) = {
    val result = decoder.decode(data.hexToBytes)
    assertEquals(
      result,
      expect
    )
  }

  test("tuple decoder") {
    val encoder = ABITypeTuple(ABITypeInt(256), ABITypeAddress)
    val data =
      "0x0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000103dd1184599c7511a3016e0a383e11f84ae7173"
    val result = encoder
      .decode(data.hexToBytes)

    assertEquals(
      result,
      (1, Address.fromHex("0x103dd1184599c7511a3016E0a383E11F84AE7173")).toJsonAst
    )
  }
  test("nested array dcoder") {
    val encoder = ABITypeTuple(
      ABITypeArray(
        ABITypeArray(ABITypeUint(256))
      )
    )
    val data =
      "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003"
    val result = encoder
      .decode(data.hexToBytes)

    assertEquals(
      result,
      Seq(Seq(Seq(1, 2, 3), Seq(1, 2, 3))).toJsonAst
    )
  }
  test("string decoder") {
    simpleDecoder(
      "0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033132330000000000000000000000000000000000000000000000000000000000",
      ABITypeTuple(ABITypeString),
      """["123"]""".fromJson[Json].toOption.get
    )
  }

  test("address decoder") {
    simpleDecoder(
      "0x0000000000000000000000003ddc12dd94592f4458d5d322ab05af332f21197c",
      ABITypeTuple(ABITypeAddress),
      """["0x3ddC12DD94592F4458D5D322Ab05Af332F21197c"]""".fromJson[Json].toOption.get
    )
  }
  test("int decoder") {
    simpleDecoder(
      "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
      ABITypeTuple(ABITypeInt(8)),
      """[-1]""".fromJson[Json].toOption.get
    )

    simpleDecoder(
      "0x0000000000000000000000000000000000000000000000000000000000000001",
      ABITypeTuple(ABITypeInt(8)),
      """[1]""".fromJson[Json].toOption.get
    )

    val result = ABITypeTuple(ABITypeUint(256)).decode(
      "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff".hexToBytes
    )
    assertEquals(
      result.asArray.get.head.asNumber.get.value.toBigInteger(),
      BigInt("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16).bigInteger
    )
  }

  test("integral codec") {
    val encoding = "0x0000000000000000000000000000000000000000000000000000000000000080ff000000000000000000000000000000000000000000000000000000000000003078313100000000000000000000000000000000000000000000000000000000307830300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000003616263000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000331323300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000036f6f6f0000000000000000000000000000000000000000000000000000000000".hexToBytes
    val codec = ABITypeTuple(
      ABITypeArray(ABITypeSizedArray(ABITypeTuple(ABITypeBool, ABITypeBytes), 3)),
      ABITypeSizedArray(ABITypeSizedBytes(32), 3)
    )
    val data = (
      Seq(Seq((true, "abc".getBytes()), (true, "123".getBytes()), (false, "ooo".getBytes()))),
      Seq("0xff".hexToBytes, "0x11".getBytes(), "0x00".getBytes())
    )
    val en = codec.encode(data)
    assertEquals(
      en.BytesToHex,
      encoding.BytesToHex
    )
    // bytes padding后无法还原了 0xff 变成0xff0000000000000000000000000000000000000
    // val de = codec.decode(encoding)
    // assertEquals(
    //   de,
    //   data.toJsonAst
    // )
  }
}
